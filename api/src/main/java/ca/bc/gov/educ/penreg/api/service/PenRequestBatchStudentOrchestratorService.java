package ca.bc.gov.educ.penreg.api.service;

import ca.bc.gov.educ.penreg.api.constants.MatchAlgorithmStatusCode;
import ca.bc.gov.educ.penreg.api.constants.PenRequestBatchStudentStatusCodes;
import ca.bc.gov.educ.penreg.api.exception.PenRegAPIRuntimeException;
import ca.bc.gov.educ.penreg.api.mappers.StudentMapper;
import ca.bc.gov.educ.penreg.api.model.*;
import ca.bc.gov.educ.penreg.api.rest.RestUtils;
import ca.bc.gov.educ.penreg.api.struct.*;
import ca.bc.gov.educ.penreg.api.util.JsonUtil;
import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static ca.bc.gov.educ.penreg.api.constants.EventOutcome.PEN_MATCH_RESULTS_PROCESSED;
import static ca.bc.gov.educ.penreg.api.constants.EventType.PROCESS_PEN_MATCH_RESULTS;
import static ca.bc.gov.educ.penreg.api.constants.PenRequestBatchStudentStatusCodes.FIXABLE;
import static ca.bc.gov.educ.penreg.api.constants.PenRequestBatchStudentStatusCodes.SYS_MATCHED;
import static lombok.AccessLevel.PRIVATE;

/**
 * The type Pen request batch student orchestrator service.
 */
@Service
@Slf4j
public class PenRequestBatchStudentOrchestratorService {
  /**
   * The constant studentMapper.
   */
  private static final StudentMapper studentMapper = StudentMapper.mapper;
  /**
   * The Pen request batch service.
   */
  @Getter(PRIVATE)
  private final PenRequestBatchService penRequestBatchService;

  /**
   * The Pen request batch service.
   */
  @Getter(PRIVATE)
  private final PenRequestBatchStudentService penRequestBatchStudentService;

  /**
   * The Rest utils.
   */
  @Getter(PRIVATE)
  private final RestUtils restUtils;


  /**
   * The Pen service.
   */
  @Getter(PRIVATE)
  private final PenService penService;

  /**
   * Instantiates a new Pen request batch student orchestrator service.
   *
   * @param penRequestBatchService        the pen request batch service
   * @param penRequestBatchStudentService the pen request batch student service
   * @param restUtils                     the rest utils
   * @param penService                    the pen service
   */
  public PenRequestBatchStudentOrchestratorService(PenRequestBatchService penRequestBatchService, PenRequestBatchStudentService penRequestBatchStudentService, RestUtils restUtils, PenService penService) {
    this.penRequestBatchService = penRequestBatchService;
    this.penRequestBatchStudentService = penRequestBatchStudentService;
    this.restUtils = restUtils;
    this.penService = penService;
  }

  /**
   * Process pen match result optional.
   * Process pen match results.
   * * this will go through and process the result based on the logic provided here.
   * * <pre>
   *    *    Update the PEN Request Student record with the outcome of the PEN Match process. Set the values of these columns:
   *    *        Match Algorithm Status Code
   *    *        Questionable Match Student ID
   *    *    IF the outcome is that the request is matched to an existing Student record: D1
   *    *        Update the PEN Request Student Status Code on the PEN Request Student record to: MATCHEDSYS
   *    *        Update the Student ID foreign key on the PEN Request Student record to specify the matched Student record.
   *    *        Update the Student table for the matched Student record (Student ID above), updating the values of the following fields, based on the values in the PEN Request Student and the PEN Request Batch record:
   *    *        Mincode (from the PEN Request Batch record)
   *    *        Local ID
   *    *        Student Grade Code
   *    *        Postal Code
   *    *        TBD: Do any of the other demographic values get updated? For K-12? For PSIs?
   *    *    ELSEIF the outcome is that a new Student/PEN record is created to fulfill the request: B0, C0, D0
   *    *        Insert a new record in the Student table based on the data from the PEN Request Student record (and Mincode from the PEN Request Batch record). This will have a new Student ID. Populate the new Student record with these values:
   *    *        These attributes come from the PEN Request Batch header:
   *    *          Mincode
   *    *          Memo = 'Generated by the system, as part of submission <Submission#>', where <Submission#> is the Submission No from the batch header
   *    *          These attributes come from the PEN Request Student detail:
   *    *          Local ID, Legal First Name, Legal Middle Names, Legal Last Name, DOB, Gender Code, Usual First Name, Usual Middle Names, Usual Last Name, Postal Code, and Student Grade Code
   *    *          These other attributes shall be:
   *    *          PEN - Generate the next new PEN number. This consists of the next 8-digit value (one more than the current largest one, in the current range of PENs who's first digit is a "1"; do not consider legacy PEN ranges whose first digit is other than a 1). Then calculate the check digit for these 8 digits, and append it as the 9th digit. This is the new PEN. See PEN Number Check-Digit Algorithm
   *    *          Email Verified = N
   *    *          Deceased Date = null
   *    *          Grade Year = null
   *    *          Demog Code = A
   *    *          Status Code = A
   *    *          Create Date, Update Date = current datetime
   *    *          Create_User, Update User = PENMATCH
   *    *          Update the Student ID foreign key on the PEN Request Student record to specify the new Student record just created.
   *    *          Update the PEN Request Student Status Code on the PEN Request Student record to: NEWPENSYS
   *    *   ELSEIF the outcome is uncertain, such that (Submitted PEN Status Code = F1 OR PEN Match Phase 1 Status Code = F1):
   *    *          Update the value of Questionable Match Student ID on the PEN Request Student record.
   *    *          Out of Scope: Run phase 2 (New Match) of the PEN match algorithm. The status on the request will remain as LOADED.
   *    *   ELSE the request requires manual review:
   *    *      Update the PEN Request Student Status Code on the PEN Request Student record to: FIXABLE
   *    *
   *    * </pre>
   *
   * @param saga                           the saga
   * @param penRequestBatchStudentSagaData the pen request batch student saga data
   * @param penMatchResult                 the pen match result
   * @return the optional
   */
  public Optional<Event> processPenMatchResult(Saga saga, PenRequestBatchStudentSagaData penRequestBatchStudentSagaData, PenMatchResult penMatchResult) {
    var algorithmStatusCode = MatchAlgorithmStatusCode.valueOf(penMatchResult.getPenStatus());
    var penRequestBatchStudent = getPenRequestBatchStudentService()
        .getStudentById(penRequestBatchStudentSagaData.getPenRequestBatchID(), penRequestBatchStudentSagaData.getPenRequestBatchStudentID());
    var penRequestBatch = getPenRequestBatchService().getPenRequestBatchEntityByID(penRequestBatchStudentSagaData.getPenRequestBatchID());
    penRequestBatchStudent.setMatchAlgorithmStatusCode(algorithmStatusCode.toString());
    Optional<Event> eventOptional;
    switch (algorithmStatusCode) {
      case D1:
        eventOptional = Optional.of(handleD1Status(saga, penMatchResult, penRequestBatchStudent, penRequestBatch));
        break;
      case B0:
      case C0:
      case D0:
        eventOptional = Optional.of(handleCreateNewStudentStatus(saga, penRequestBatchStudentSagaData, penRequestBatchStudent, penMatchResult));
        break;
      case F1:
        eventOptional = Optional.of(handleF1Status(saga, penMatchResult, penRequestBatchStudent));
        break;
      default:
        eventOptional = Optional.of(handleDefault(saga, penRequestBatchStudent, penMatchResult));
        break;
    }
    return eventOptional;
  }

  /**
   * Handle f 1 status event.
   *
   * @param saga                   the saga
   * @param penMatchResult         the pen match result
   * @param penRequestBatchStudent the pen request batch student
   * @return the event
   */
  private Event handleF1Status(Saga saga, PenMatchResult penMatchResult, PenRequestBatchStudentEntity penRequestBatchStudent) {
    var penMatchRecordOptional = penMatchResult.getMatchingRecords().stream().findFirst();
    penMatchRecordOptional.ifPresent(penMatchRecord -> penRequestBatchStudent.setQuestionableMatchStudentId(UUID.fromString(penMatchRecord.getStudentID())));
    getPenRequestBatchStudentService().saveAttachedEntity(penRequestBatchStudent);
    return Event.builder().sagaId(saga.getSagaId())
        .eventType(PROCESS_PEN_MATCH_RESULTS).eventOutcome(PEN_MATCH_RESULTS_PROCESSED)
        .eventPayload(penMatchResult.getPenStatus()).build();
  }

  /**
   * Handle default.
   *
   * @param saga                   the saga
   * @param penRequestBatchStudent the pen request batch student
   * @param penMatchResult         the pen match result
   * @return the event
   */
  private Event handleDefault(Saga saga, PenRequestBatchStudentEntity penRequestBatchStudent, PenMatchResult penMatchResult) {
    penRequestBatchStudent.setPenRequestBatchStudentStatusCode(FIXABLE.getCode());
    getPenRequestBatchStudentService().saveAttachedEntity(penRequestBatchStudent);
    return Event.builder().sagaId(saga.getSagaId())
        .eventType(PROCESS_PEN_MATCH_RESULTS).eventOutcome(PEN_MATCH_RESULTS_PROCESSED)
        .eventPayload(penMatchResult.getPenStatus()).build();
  }

  /**
   * Handle create new student status.
   *
   * @param saga                           the saga
   * @param penRequestBatchStudentSagaData the pen request batch student saga data
   * @param penRequestBatchStudent         the pen request batch student
   * @param penMatchResult                 the pen match result
   * @return the event
   */
  private Event handleCreateNewStudentStatus(Saga saga, PenRequestBatchStudentSagaData penRequestBatchStudentSagaData, PenRequestBatchStudentEntity penRequestBatchStudent, PenMatchResult penMatchResult) {
    var pen = generateNewPen(saga.getSagaId().toString());
    var student = studentMapper.toStudent(penRequestBatchStudentSagaData);
    student.setPen(pen);
    var studentFromAPIResponse = getRestUtils().createStudent(student);
    penRequestBatchStudent.setStudentID(UUID.fromString(studentFromAPIResponse.getStudentID()));
    getPenRequestBatchStudentService().saveAttachedEntity(penRequestBatchStudent);
    return Event.builder().sagaId(saga.getSagaId())
        .eventType(PROCESS_PEN_MATCH_RESULTS).eventOutcome(PEN_MATCH_RESULTS_PROCESSED)
        .eventPayload(penMatchResult.getPenStatus()).build();
  }

  /**
   * Handle d 1 status.
   *
   * @param saga                   the saga
   * @param penMatchResult         the pen match result
   * @param penRequestBatchStudent the pen request batch student
   * @param penRequestBatch        the pen request batch
   * @return the event
   */
  private Event handleD1Status(Saga saga, PenMatchResult penMatchResult, PenRequestBatchStudentEntity penRequestBatchStudent, java.util.Optional<PenRequestBatchEntity> penRequestBatch) {
    var penMatchRecordOptional = penMatchResult.getMatchingRecords().stream().findFirst();
    if (penMatchRecordOptional.isPresent()) {
      var studentID = penMatchRecordOptional.get().getStudentID();
      penRequestBatchStudent.setPenRequestBatchStudentStatusCode(SYS_MATCHED.getCode());
      penRequestBatchStudent.setStudentID(UUID.fromString(studentID));
      penRequestBatchStudent = getPenRequestBatchStudentService().saveAttachedEntity(penRequestBatchStudent);
      var studentFromStudentAPI = getRestUtils().getStudentByStudentID(studentID);
      if (penRequestBatch.isPresent()) {
        updateStudentData(studentFromStudentAPI, penRequestBatchStudent, penRequestBatch.get());
        getRestUtils().updateStudent(studentFromStudentAPI);
        return Event.builder().sagaId(saga.getSagaId())
            .eventType(PROCESS_PEN_MATCH_RESULTS).eventOutcome(PEN_MATCH_RESULTS_PROCESSED)
            .eventPayload(penMatchResult.getPenStatus()).build();
      } else { // sometime JAVA is dumb , we know for sure it is present and else will never be executed.
        log.error("Pen Request Batch was not present, this should not have happened.");
        throw new PenRegAPIRuntimeException("Pen Request Batch was not present.");
      }
    } else {
      log.error("PenMatchRecord in priority queue is empty for status D1, this should not have happened.");
      throw new PenRegAPIRuntimeException("PenMatchRecord in priority queue is empty for status D1, this should not have happened.");
    }
  }


  /**
   * Generate new pen string.
   *
   * @param guid the guid to identify the transaction.
   * @return the string
   */
  private String generateNewPen(String guid) {
    log.info("generate new pen called for guid :: {}", guid);
    return getPenService().getNextPenNumber(guid);
  }

  /**
   * This method updates the below.
   * Update the Student table for the matched Student record (Student ID above),
   * updating the values of the following fields, based on the values in the PEN Request Student and the PEN Request Batch record:
   * Mincode (from the PEN Request Batch record)
   * Local ID
   * Student Grade Code
   * Postal Code
   * TBD: Do any of the other demographic values get updated? For K-12? For PSIs?
   *
   * @param studentFromStudentAPI  the student from student api
   * @param penRequestBatchStudent the pen request batch student
   * @param penRequestBatchEntity  the pen request batch entity
   */
  private void updateStudentData(Student studentFromStudentAPI, PenRequestBatchStudentEntity penRequestBatchStudent, PenRequestBatchEntity penRequestBatchEntity) {
    studentFromStudentAPI.setMincode(penRequestBatchEntity.getMinCode());
    studentFromStudentAPI.setLocalID(penRequestBatchStudent.getLocalID());
    studentFromStudentAPI.setGradeCode(penRequestBatchStudent.getGradeCode());
    studentFromStudentAPI.setPostalCode(penRequestBatchStudent.getPostalCode());
    studentFromStudentAPI.setUpdateUser("PEN_REG_BATCH_API");
  }

  /**
   * Save demog validation results and update student status.
   *
   * @param validationIssueEntities  the validation issue entities
   * @param statusCode               the status code
   * @param penRequestBatchStudentID the pen request batch student id
   */
  @Retryable(value = {Exception.class}, maxAttempts = 10, backoff = @Backoff(multiplier = 2, delay = 2000))
  public void saveDemogValidationResultsAndUpdateStudentStatus(List<PenRequestBatchStudentValidationIssueEntity> validationIssueEntities, PenRequestBatchStudentStatusCodes statusCode, UUID penRequestBatchStudentID) {
    var studentOptional = getPenRequestBatchStudentService().findByID(penRequestBatchStudentID);
    if (studentOptional.isPresent()) {
      var student = studentOptional.get();
      student.setPenRequestBatchStudentStatusCode(statusCode.getCode());
      student.setUpdateDate(LocalDateTime.now());
      student.setUpdateUser("PEN_REQUEST_BATCH_API");
      validationIssueEntities.forEach(el -> el.setPenRequestBatchStudentEntity(student)); // create the PK/FK relationship
      student.getPenRequestBatchStudentValidationIssueEntities().addAll(validationIssueEntities);
      getPenRequestBatchStudentService().saveAttachedEntity(student);

    } else {
      log.error("Student request record could not be found for :: {}", penRequestBatchStudentID);
    }
  }

  /**
   * the method makes a deep clone as it needs the original payload to do comparison and update fields.
   * Perform the following actions on the CurrentRequest:
   * <p>
   * Remove periods from all legal and usual names elements
   * Convert all name elements to all UPPER case.
   * Change tab characters within name elements to single spaces
   * Remove leading and trailing spaces from all name elements
   * Convert multiple contiguous spaces within any name element to a single space
   * Blank out usual name if it is an initial (a single character)
   * Blank out each of the three usual name elements if it is the same as the corresponding legal name element
   * Blank out usual middle name if it is the same as legal given name
   * Blank out usual middle name if it is the same as usual given name
   * Blank out usual middle name if it is the same as (legal given name + space + legal middle name)
   * Blank out usual middle name if it is contained within legal middle name
   *
   * @param payload the payload which needs to be updated.
   * @return the updated payload.
   * @throws JsonProcessingException the json processing exception
   */
  public PenRequestBatchStudentValidationPayload scrubValidationPayload(PenRequestBatchStudentValidationPayload payload) throws JsonProcessingException {
    PenRequestBatchStudentValidationPayload updatedPayload = JsonUtil.getJsonObjectFromString(PenRequestBatchStudentValidationPayload.class, JsonUtil.getJsonStringFromObject(payload));
    if (StringUtils.isNotBlank(payload.getLegalLastName())) {
      updatedPayload.setLegalLastName(scrubNameField(payload.getLegalLastName()));
    }
    if (StringUtils.isNotBlank(payload.getLegalFirstName())) {
      updatedPayload.setLegalFirstName(scrubNameField(payload.getLegalFirstName()));
    }
    if (StringUtils.isNotBlank(payload.getLegalMiddleNames())) {
      updatedPayload.setLegalMiddleNames(scrubNameField(payload.getLegalMiddleNames()));
    }
    var usualFirstName = payload.getUsualFirstName();
    if (StringUtils.isNotEmpty(usualFirstName)
        && (usualFirstName.trim().length() == 1) || (usualFirstName.trim().equalsIgnoreCase(payload.getLegalFirstName()))) {
      updatedPayload.setUsualFirstName("");
    }
    var usualLastName = payload.getUsualLastName();
    if (StringUtils.isNotEmpty(usualLastName)
        && (usualLastName.trim().length() == 1) || (usualLastName.trim().equalsIgnoreCase(payload.getLegalLastName()))) {
      updatedPayload.setUsualLastName("");
    }
    var usualMiddleName = payload.getUsualMiddleNames();
    if (doesMiddleNameNeedsToBeBlank(usualMiddleName, payload)) {
      updatedPayload.setUsualMiddleNames("");
    }

    return updatedPayload;
  }

  /**
   * Blank out usual middle name if it is the same as legal given name
   * Blank out usual middle name if it is the same as usual given name
   * Blank out usual middle name if it is the same as (legal given name + space + legal middle name)
   * Blank out usual middle name if it is contained within legal middle name
   *
   * @param usualMiddleName the usual middle name
   * @param payload         the payload
   * @return boolean boolean
   */
  private boolean doesMiddleNameNeedsToBeBlank(String usualMiddleName, PenRequestBatchStudentValidationPayload payload) {
    return StringUtils.isNotEmpty(usualMiddleName)
        && (usualMiddleName.trim().length() == 1
        || areBothFieldValueEqual(usualMiddleName, payload.getLegalMiddleNames())
        || areBothFieldValueEqual(usualMiddleName, payload.getLegalFirstName())
        || (StringUtils.isNotBlank(payload.getLegalMiddleNames()) && payload.getLegalMiddleNames().contains(usualMiddleName))
        || (usualMiddleName.trim().equals(payload.getLegalFirstName() + " " + payload.getLegalMiddleNames())));
  }

  /**
   * Are both field value equal boolean.
   *
   * @param field1 the field 1
   * @param field2 the field 2
   * @return the boolean
   */
  protected boolean areBothFieldValueEqual(String field1, String field2) {
    return ((field1 == null && field2 == null)
        || (field1 != null && field2 != null && field1.trim().equals(field2.trim())));
  }

  /**
   * This method is responsible to do the following.
   * 1.Remove periods from all legal and usual names elements
   * 2.Convert all name elements to all UPPER case.
   * 3.Change tab characters within name elements to single spaces
   * 4.Remove leading and trailing spaces from all name elements
   * 5.Convert multiple contiguous spaces within any name element to a single space
   *
   * @param nameFieldValue the value of the name field
   * @return modified string value.
   */
  protected String scrubNameField(String nameFieldValue) {
    return nameFieldValue.trim().toUpperCase().replace("\t", " ").replace(".", "").replaceAll("\\s{2,}", " ");
  }

  @Retryable(value = {Exception.class}, maxAttempts = 10, backoff = @Backoff(multiplier = 2, delay = 2000))
  public void persistPossibleMatches(UUID penRequestBatchStudentID, List<PenMatchRecord> penMatchRecords) {
    var studentOptional = getPenRequestBatchStudentService().findByID(penRequestBatchStudentID);
    if (studentOptional.isPresent()) {

      var student = studentOptional.get();
      int priority = 1;
      for (var penMatchRecord : penMatchRecords) {
        PenRequestBatchStudentPossibleMatchEntity entity = new PenRequestBatchStudentPossibleMatchEntity();
        entity.setMatchedPen(penMatchRecord.getMatchingPEN());
        entity.setMatchedPriority(priority++);
        entity.setMatchedStudentId(UUID.fromString(penMatchRecord.getStudentID()));
        entity.setPenRequestBatchStudentEntity(student); // PK/FK relationship.
        student.getPenRequestBatchStudentPossibleMatchEntities().add(entity);
      }
      getPenRequestBatchStudentService().saveAttachedEntity(student);
    }
  }

}
